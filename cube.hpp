// cube.hpp
// (C) 2023 ePi
//
// このコードは、Cube LUT Specification Version 1.0に完全準拠した
// cubeファイルの取り扱いを行うクラスを提供する。
//
// ref: https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf
//
// note:
//   規格違反の改行をするけしからんcubeファイルがあまりに多いので、読み取りは成功させることにしている
//

#pragma once
#include <iostream>
#include <fstream>
#include <charconv>
#include <vector>
#include <optional>
#include <filesystem>
#include <array>
#include <cstdint>
#include <utility>
#include <string_view>
#include <exception>
#include <format>
#include <ranges>
#include <cmath>
#include <tuple>
#include <execution>
#include <memory>
#include <variant>

#include <boost/container/vector.hpp>

namespace CubeHpp {
	using Domain = std::array<float, 3>;
}

template<>
struct std::formatter<CubeHpp::Domain> {
	constexpr auto parse(std::format_parse_context& ctx) {
		return ctx.begin();
	}

	auto format(const CubeHpp::Domain& d, std::format_context& ctx) {
		return std::format_to(ctx.out(), "{} {} {}", d[0], d[1], d[2]);
	}
};

namespace CubeHpp {
	enum class CubeType {
		c_invaild = 0,
		c_1d = 1,
		c_3d = 3
	};

	class cube_exception : public std::runtime_error {
	public:
		cube_exception() : std::runtime_error{"(Empty CubeHpp::cube_exception)"} {}
		cube_exception(const char* str) : std::runtime_error{str} {}
	};

	class file_format_exception : public cube_exception {
	public:
		file_format_exception() : cube_exception{} {}
		file_format_exception(const char* str) : cube_exception{str} {}
	};

	class type_invalid_exception : public cube_exception {
	public:
		type_invalid_exception() : cube_exception{} {}
		type_invalid_exception(const char* str) : cube_exception{str} {}
	};

	class out_of_range_exception : public cube_exception {
	public:
		out_of_range_exception() : cube_exception{} {}
		out_of_range_exception(const char* str) : cube_exception{str} {}
	};

	class invalid_domain_range_exception : public cube_exception {
	public:
		invalid_domain_range_exception() : cube_exception{} {}
		invalid_domain_range_exception(const char* str) : cube_exception{str} {}
	};

	inline static constexpr std::string_view HEAD_TITLE = "TITLE";
	inline static constexpr const char HEAD_TITLE_Q = '"';
	inline static constexpr std::string_view HEAD_DOMAIN_MIN = "DOMAIN_MIN";
	inline static constexpr std::string_view HEAD_DOMAIN_MAX = "DOMAIN_MAX";
	inline static constexpr std::string_view HEAD_LUT_1D_SIZE = "LUT_1D_SIZE";
	inline static constexpr std::string_view HEAD_LUT_3D_SIZE = "LUT_3D_SIZE";
	inline static constexpr std::string_view TOKENS_SP = " \t";
	inline static constexpr char TOKEN_NL = '\n';
	inline static constexpr char TOKEN_COMMENT = '#';
	inline static constexpr char TOKEN_NL_R = '\r';

	inline static constexpr Domain domain_min_default = { 0,0,0 };
	inline static constexpr Domain domain_max_default = { 1,1,1 };

	namespace detail {
		inline constexpr static std::string_view HEAD_CUBEHPP_COMMENT = "# Cube LUT file generated by cube.hpp\n";
	}

	constexpr Domain lerp(const Domain& a, const Domain& b, float t) noexcept {
		const auto s = 1.f - t;
		return {
			a[0] * s + b[0] * t,
			a[1] * s + b[1] * t,
			a[2] * s + b[2] * t,
		};
	}
	
	struct cube_base {
		size_t size;
		std::optional<std::string> title;
		std::vector<Domain> domains;
		std::optional<Domain> domain_min;
		std::optional<Domain> domain_max;

		auto parse_idx(float x) const {
			float divf;
			auto rem = std::modf(x, &divf);
			auto divi = static_cast<size_t>(divf);
			if (!(0 <= divi && divi < size)) throw out_of_range_exception{};
			return std::make_pair(divi, rem);
		};
	};
	
	class cube_reader : public cube_base {
		using file_buf = boost::container::vector<char>;
		using file_buf_itr = file_buf::const_iterator;

		inline static struct {
			constexpr auto operator()(char c) noexcept {
				return TOKENS_SP.find(c) != std::string::npos;
			}
		} is_space;

		inline static struct {
			constexpr auto operator()(const char* start, const char* last) const noexcept {
				for (; start != last; ++start) {
					if (!is_space(*start)) return start;
				}
				return last;
			}
		} skip_space;

		inline static struct {
			template<std::input_iterator I>
			constexpr auto operator()(I start_itr, I last_itr) const {
				auto start = std::to_address(start_itr);
				auto last = std::to_address(last_itr);

				float f1, f2, f3;
				std::from_chars_result result;

				result = std::from_chars(start, last, f1);
				if (result.ec != std::errc{}) throw file_format_exception{};

				start = skip_space(result.ptr, last);
				if (start == last) throw file_format_exception{};

				result = std::from_chars(start, last, f2);
				if (result.ec != std::errc{}) throw file_format_exception{};

				start = skip_space(result.ptr, last);
				if (start == last) throw file_format_exception{};

				result = std::from_chars(start, last, f3);
				if (result.ec != std::errc{}) throw file_format_exception{};

				return std::array{ f1, f2, f3 };
			}
		} read_domain;

		inline static constexpr auto is_nl = [](char c) noexcept {
			return c == TOKEN_NL || c == TOKEN_NL_R;
		};

		inline static constexpr auto equal_head = [](std::input_iterator auto start, std::string_view head) noexcept {
			return std::equal(head.cbegin(), head.cend(), start);
		};
		 
		inline static constexpr auto read_file_all = [](const std::filesystem::path& path) {
			file_buf ret{};

			auto file_size = std::filesystem::file_size(path);
			if (!std::in_range<size_t>(file_size)) throw file_format_exception{};
			ret.resize(static_cast<size_t>(file_size), boost::container::default_init);
			std::ifstream file(path, std::ios::binary);
			file.read(ret.data(), file_size);

			return ret;
		};
		
		file_buf_itr parse_head() {
			auto itr1 = std::ranges::cbegin(buf);
			decltype(itr1) itr2;

			while (true) {
				itr2 = std::find_if(itr1, std::ranges::cend(buf), is_nl);
				if (itr2 == std::ranges::cend(buf)) {
					return itr1;
				}
				else {
					if (std::ranges::distance(itr1, itr2) > 250) throw file_format_exception{};
				}

				switch (*itr1) {
				case TOKEN_COMMENT:
				case TOKEN_NL:
				case TOKEN_NL_R:
					break;
				case 'D': {
					if (equal_head(itr1, HEAD_DOMAIN_MIN)) {
						if (domain_min.has_value()) throw file_format_exception{};
						auto itr3 = std::find_if_not(itr1 + HEAD_DOMAIN_MIN.size(), itr2, is_space);
						domain_min = read_domain(itr3, itr2);
					}
					else if (equal_head(itr1, HEAD_DOMAIN_MAX)) {
						if (domain_max.has_value()) throw file_format_exception{};
						auto itr3 = std::find_if_not(itr1 + HEAD_DOMAIN_MIN.size(), itr2, is_space);
						domain_max = read_domain(itr3, itr2);
					}
					else throw file_format_exception{};
					break;
				}
				case 'L': {
					if (type != CubeType::c_invaild) throw file_format_exception{};

					if (equal_head(itr1, HEAD_LUT_1D_SIZE)) {
						type = CubeType::c_1d;
						auto itr3 = std::find_if_not(itr1 + HEAD_LUT_1D_SIZE.size(), itr2, is_space);
						if (auto [_, ec] = std::from_chars(std::to_address(itr3), std::to_address(itr2), size); ec != std::errc{}) throw file_format_exception{};
					}
					else if (equal_head(itr1, HEAD_LUT_3D_SIZE)) {
						type = CubeType::c_3d;
						auto itr3 = std::find_if_not(itr1 + HEAD_LUT_3D_SIZE.size(), itr2, is_space);
						if (auto [_, ec] = std::from_chars(std::to_address(itr3), std::to_address(itr2), size); ec != std::errc{}) throw file_format_exception{};
					}
					else throw file_format_exception{};
					break;
				}
				case 'T': {
					if (equal_head(itr1, HEAD_TITLE)) {
						auto itr3 = std::find(itr1 + HEAD_TITLE.size(), itr2, HEAD_TITLE_Q);

						auto itr4{ itr2 };
						for (; itr4 != itr3; itr4--) {
							if (*itr4 == HEAD_TITLE_Q) break;
						}
						if (itr3 == itr2 || std::distance(itr3, itr4) < 2)  throw file_format_exception{};
						title.emplace(std::next(itr3), std::prev(itr4));
					}
					else throw file_format_exception{};
					break;
				}
				default:
					return itr1;
				}
				itr1 = std::next(itr2);
			}
		}

		void check_head() {
			switch (type) {
				case CubeType::c_1d:
					if (!(2 <= size && size <= 65536))
						throw file_format_exception{};
					break;
				case CubeType::c_3d:
					if (!(2 <= size && size <= 256))
						throw file_format_exception{};
					break;
				default:
					throw file_format_exception{};
			}

			const auto l_domain_min = domain_min.value_or(domain_min_default);
			const auto l_domain_max = domain_max.value_or(domain_max_default);

			if (!(
				l_domain_min[0] < l_domain_max[0] &&
				l_domain_min[1] < l_domain_max[1] &&
				l_domain_min[2] < l_domain_max[2]
			)) throw file_format_exception{};
		}

		void parse_body(file_buf_itr begin, file_buf_itr end) {
			auto itr1{begin};
			auto itr2 = std::find_if(itr1, end, is_nl);

			auto linenum = size;
			if (type == CubeType::c_3d) {
				linenum *= size * size;
			}
			domains.reserve(linenum);

			while (itr1 != end && domains.size() <= linenum) {
				switch (*itr1) {
					case TOKEN_NL:
					case TOKEN_NL_R:
					case TOKEN_COMMENT:
						break;
					default: {
						domains.push_back(read_domain(itr1, itr2));
					}
				}
				itr1 = itr2 + 1;
				itr2 = std::find_if(itr1, end, is_nl);
			}
			if (domains.size() != linenum) throw file_format_exception{};
		}
			
		file_buf buf;

	public:
		CubeType type;

		cube_reader(const std::filesystem::path& path) : buf{ read_file_all(path) }, type{CubeType::c_invaild} {
			auto body_itr = parse_head();
			check_head();
			parse_body(body_itr, buf.cend());
		}

		auto get_type() const noexcept { return type; }
	};


	class cube1d : public cube_base {
	public:
		cube1d(cube_base&& b) : cube_base{ std::move(b) } {}

		[[nodiscard]] Domain index(float x, float y, float z) const {
			auto [ix, tx] = parse_idx(x);
			auto [iy, ty] = parse_idx(y);
			auto [iz, tz] = parse_idx(z);

			auto indexer = [this](size_t ix, float tx, int e) {
				if (ix == size - 1) [[unlikely]] {
					return domains[ix][e];
				}
				else {
					return std::lerp(domains[ix][e], domains[ix + 1][e], tx);
				}
			};

			return {
				indexer(ix, tx, 0),
				indexer(iy, ty, 1),
				indexer(iz, tz, 2)
			};
		}

		inline static constexpr CubeType type = CubeType::c_1d;

		void write_head_size(std::ostreambuf_iterator<char> itr) const {
			std::format_to(itr, "{} {}\n", HEAD_LUT_1D_SIZE, size);
		}

		[[nodiscard]] constexpr size_t get_domains_size() const noexcept {
			return size;
		}
	};

	class cube3d : public cube_base {
	protected:
		[[nodiscard]] constexpr size_t idx3d(size_t x, size_t y, size_t z) const {
			return x + (y + z * size) * size;
		}

		[[nodiscard]] constexpr auto& index3d(this auto&& self, size_t x, size_t y, size_t z) {
			return self.domains[self.idx3d(x, y, z)];
		}

	public:
		cube3d(cube_base&& b) : cube_base{std::move(b)} {}

		[[nodiscard]] Domain index(float x, float y, float z) const {
			auto [ix, tx] = parse_idx(x);
			auto [iy, ty] = parse_idx(y);
			auto [iz, tz] = parse_idx(z);

			auto mul = [](const Domain& x, float c) -> Domain {
				return {
					x[0] * c,
					x[1] * c,
					x[2] * c
				};
			};

			auto sum_4d = [](const Domain& d1, const Domain& d2, const Domain& d3, const Domain& d4) -> Domain {
				return {
					d1[0] + d2[0] + d3[0] + d4[0],
					d1[1] + d2[1] + d3[1] + d4[1],
					d1[2] + d2[2] + d3[2] + d4[2],
				};
			};

			auto next = [size = this->size](size_t i) {
				if (i == size) return size - 1;
				return i;
			};

			#define xyz() (index3d(ix      , iy      , iz      ))
			#define Xyz() (index3d(next(ix), iy      , iz      ))
			#define xYz() (index3d(ix      , next(iy), iz      ))
			#define XYz() (index3d(next(ix), next(iy), iz      ))
			#define xyZ() (index3d(ix      , iy      , next(iz)))
			#define XyZ() (index3d(next(ix), iy      , next(iz)))
			#define xYZ() (index3d(ix      , next(iy), next(iz)))
			#define XYZ() (index3d(next(ix), next(iy), next(iz)))

			if (ty >= tz) {
				if (tz >= tx) {
					return sum_4d(
						mul(xyz(), 1 - ty),
						mul(xYz(), ty - tz),
						mul(xYZ(), tz - tx),
						mul(XYZ(), tx)
					);
				}
				else {
					if (tx >= ty) {
						return sum_4d(
							mul(xyz(), 1 - tx),
							mul(Xyz(), tx - ty),
							mul(XYz(), ty - tz),
							mul(XYZ(), tz)
						);
					}
					else {
						return sum_4d(
							mul(xyz(), 1 - ty),
							mul(xYz(), ty - tx),
							mul(XYz(), tx - tz),
							mul(XYZ(), tz)
						);
					}
				}
			}
			else {
				if (tx >= ty) {
					if (tz >= tx) {
						return sum_4d(
							mul(xyz(), 1 - tz),
							mul(xyZ(), tz - tx),
							mul(XyZ(), tx - ty),
							mul(XYZ(), ty)
						);
					}
					else {
						return sum_4d(
							mul(xyz(), 1 - tx),
							mul(Xyz(), tx - tz),
							mul(XyZ(), tz - ty),
							mul(XYZ(), ty)
						);
					}
				}
				else {
					return sum_4d(
						mul(xyz(), 1 - tz),
						mul(xyZ(), tz - ty),
						mul(xYZ(), ty - tx),
						mul(XYZ(), tx)
					);
				}
			}
			#undef xyz
			#undef Xyz
			#undef xYz
			#undef XYz
			#undef xyZ
			#undef XyZ
			#undef xYZ
			#undef XYZ
		}

		inline static constexpr CubeType type = CubeType::c_3d;

		void write_head_size(std::ostreambuf_iterator<char> itr) const {
			std::format_to(itr, "{} {}\n", HEAD_LUT_3D_SIZE, size);
		}

		constexpr size_t get_domains_size() const noexcept {
			return size * size * size;
		}
	};

	class cube {
		std::variant<cube1d, cube3d> obj;

		using obj_t = decltype(obj);
	public:
		[[nodiscard]] cube(CubeType type, cube_base&& prop) : obj{
			[type, &prop]() -> obj_t {
				switch (type) {
					case CubeType::c_1d:
						return cube1d{ std::move(prop) };
					case CubeType::c_3d:
						return cube3d{ std::move(prop) };
					default:
						throw type_invalid_exception{ "cube::cube" };
				}
			}()
		} {}

		[[nodiscard]] Domain index(float x, float y, float z) const {
			return std::visit<Domain>([x, y, z](const auto& o) { return o.index(x, y, z); }, obj);
		}

		[[nodiscard]] constexpr CubeType type() const {
			return std::visit([](const auto& o) { return o.type; }, obj);
		}

		[[nodiscard]] constexpr size_t size() const {
			return std::visit([](const auto& o) { return o.size; }, obj);
		}

		[[nodiscard]] constexpr auto& at(this auto&& self, size_t i) {
			return std::visit([i](auto&& o) -> auto& { return o.domains[i]; }, self.obj);
		}

		[[nodiscard]] constexpr auto& title(this auto&& self) {
			return std::visit([](auto&& o) -> auto& { return o.title; }, self.obj);
		}

		static constexpr struct {
			void operator()(const auto& o, Domain& d) const {
				d = o.index(d[0], d[1], d[2]);
			}

			void operator()(const auto& o, Domain& d, float t) const {
				d = lerp(d, o.index(d[0], d[1], d[2]), t);
			}
		} apply_o{};

		void apply(Domain& d) const {
			std::visit([&d](const auto& o) { apply_o(o, d); }, obj);
		}

		void apply(Domain& d, float t) const {
			std::visit([&d, t](const auto& o) { apply_o(o, d, t); }, obj);
		}
		
		template<std::ranges::input_range R>
		requires std::same_as<std::ranges::range_value_t<R>, Domain>
		void apply(R&& r) const {
			std::visit([&r](const auto& o) {
				std::for_each(
					#ifndef _DEBUG
						std::execution::par_unseq,
					#endif
					std::ranges::begin(r), std::ranges::end(r),
					[&o](Domain& d) {
						apply_o(o, d);
					}
				);
			}, obj);
		}
		
		template<std::ranges::input_range R>
		requires std::same_as<std::ranges::range_value_t<R>, Domain>
		void apply(R&& r, float t) const {
			std::visit([&r, t](const auto& o) {
				std::for_each(
					std::execution::par_unseq,
					std::ranges::begin(r), std::ranges::end(r),
					[&o, t](Domain& d) {
						apply_o(o, d, t);
					}
				);
			}, obj);
		}

		void save(const std::filesystem::path& path) const {
			std::visit([&path](const auto& o) {
				std::ofstream ofs{ path, std::ios::binary };
				std::ostreambuf_iterator itr{ ofs };

				ofs << detail::HEAD_CUBEHPP_COMMENT;

				if (o.title.has_value()) std::format_to(itr, "{} \"{}\"\n", HEAD_TITLE, o.title.value());

				if (o.domain_min.has_value()) { std::format_to(itr, "{} {}\n", HEAD_DOMAIN_MIN, o.domain_min.value()); };
				if (o.domain_max.has_value()) { std::format_to(itr, "{} {}\n", HEAD_DOMAIN_MAX, o.domain_max.value()); };

				o.write_head_size(itr);

				for (size_t i : std::views::iota(size_t{ 0 }, o.get_domains_size())) {
					std::format_to(itr, "{}\n", o.domains[i]);
				}
			}, obj);
		}
	};

	using BGRA32 = std::array<uint8_t, 4>;


	class cube_bgra32_base {
		struct map_data {
			uint8_t min;
			uint8_t max;
			float t;
		};
	public:
		float resolution;
		std::array<map_data, 256> idx_map;

		cube_bgra32_base(size_t size) : resolution{ (size - 1) / 255.f } {
			for (int i = 0; i < 256; i++) {
				const auto a = i * resolution;
				float mnf;
				auto t = std::modf(a, &mnf);
				auto mxf = std::ceil(a);
				idx_map[i] = {
					static_cast<uint8_t>(mnf),
					static_cast<uint8_t>(mxf),
					t
				};
			}
		}

		const auto& get_map(uint8_t x) const {
			return idx_map[x];
		}
	};

	class cube1d_bgra32 : public cube1d, public cube_bgra32_base {
	public:
		cube1d_bgra32(cube_base&& b) :
			cube1d{ std::move(b) },
			cube_bgra32_base{ size }
		{}

		using cube1d::index;

		[[nodiscard]] Domain index(uint8_t xx, uint8_t yy, uint8_t zz) const {
			auto&& [ix1, ix2, tx] = get_map(xx);
			auto&& [iy1, iy2, ty] = get_map(yy);
			auto&& [iz1, iz2, tz] = get_map(zz);

			return {
				std::lerp(domains[ix1][0], domains[ix2][0], tx),
				std::lerp(domains[iy1][1], domains[iy2][1], ty),
				std::lerp(domains[iz1][2], domains[iz2][2], tz),
			};
		}
	};

	class cube3d_bgra32 : public cube3d, public cube_bgra32_base {
	public:
		cube3d_bgra32(cube_base&& b) :
			cube3d{ std::move(b) },
			cube_bgra32_base{ size }
		{}

		using cube3d::index;

		[[nodiscard]] Domain index(uint8_t xx, uint8_t yy, uint8_t zz) const {
			const auto& [ix1, ix2, tx] = get_map(xx);
			const auto& [iy1, iy2, ty] = get_map(yy);
			const auto& [iz1, iz2, tz] = get_map(zz);
			
			auto next = [size = this->size](size_t i) {
				if (i == size) return size - 1;
				return i;
			};

			auto mul = [](const Domain& x, float c) -> Domain {
				return {
					x[0] * c,
					x[1] * c,
					x[2] * c,
				};
			};

			auto sum_4d = [](const Domain& d1, const Domain& d2, const Domain& d3, const Domain& d4) -> Domain {
				return {
					d1[0] + d2[0] + d3[0] + d4[0],
					d1[1] + d2[1] + d3[1] + d4[1],
					d1[2] + d2[2] + d3[2] + d4[2],
				};
			};

			#define xyz() (index3d(ix1, iy1, iz1))
			#define Xyz() (index3d(ix2, iy1, iz1))
			#define xYz() (index3d(ix1, iy2, iz1))
			#define XYz() (index3d(ix2, iy2, iz1))
			#define xyZ() (index3d(ix1, iy1, iz2))
			#define XyZ() (index3d(ix2, iy1, iz2))
			#define xYZ() (index3d(ix1, iy2, iz2))
			#define XYZ() (index3d(ix2, iy2, iz2))

			if (ty >= tz) {
				if (tz >= tx) {
					return sum_4d(
						mul(xyz(), 1 - ty),
						mul(xYz(), ty - tz),
						mul(xYZ(), tz - tx),
						mul(XYZ(), tx)
					);
				}
				else {
					if (tx >= ty) {
						return sum_4d(
							mul(xyz(), 1 - tx),
							mul(Xyz(), tx - ty),
							mul(XYz(), ty - tz),
							mul(XYZ(), tz)
						);
					}
					else {
						return sum_4d(
							mul(xyz(), 1 - ty),
							mul(xYz(), ty - tx),
							mul(XYz(), tx - tz),
							mul(XYZ(), tz)
						);
					}
				}
			}
			else {
				if (tx >= ty) {
					if (tz >= tx) {
						return sum_4d(
							mul(xyz(), 1 - tz),
							mul(xyZ(), tz - tx),
							mul(XyZ(), tx - ty),
							mul(XYZ(), ty)
						);
					}
					else {
						return sum_4d(
							mul(xyz(), 1 - tx),
							mul(Xyz(), tx - tz),
							mul(XyZ(), tz - ty),
							mul(XYZ(), ty)
						);
					}
				}
				else {
					return sum_4d(
						mul(xyz(), 1 - tz),
						mul(xyZ(), tz - ty),
						mul(xYZ(), ty - tx),
						mul(XYZ(), tx)
					);
				}
			}
			#undef xyz
			#undef Xyz
			#undef xYz
			#undef XYz
			#undef xyZ
			#undef XyZ
			#undef xYZ
			#undef XYZ
		}
	};

	
	class cube_bgra32 {
		std::variant<cube1d_bgra32, cube3d_bgra32> obj;
		using obj_t = decltype(obj);

		void save_checked(const std::filesystem::path& path, const Domain& s_domain_min, const Domain& s_domain_max) const {
			std::visit([&path, &s_domain_min, &s_domain_max](const auto& o) {
				std::ofstream ofs{ path, std::ios::binary };
				std::ostreambuf_iterator itr{ ofs };

				ofs << detail::HEAD_CUBEHPP_COMMENT;

				if (o.title.has_value()) std::format_to(itr, "{} \"{}\"\n", HEAD_TITLE, o.title.value());

				std::format_to(itr, "{} {}\n", HEAD_DOMAIN_MIN, s_domain_min);
				std::format_to(itr, "{} {}\n", HEAD_DOMAIN_MAX, s_domain_max);

				o.write_head_size(itr);

				const Domain domain_a = {
					(s_domain_max[0] - s_domain_min[0]) / 255,
					(s_domain_max[1] - s_domain_min[1]) / 255,
					(s_domain_max[2] - s_domain_min[2]) / 255,
				};
				for (size_t i : std::views::iota(size_t{ 0 }, o.get_domains_size())) {
					Domain d{
						o.domains[i][0] * domain_a[0] + s_domain_min[0],
						o.domains[i][1] * domain_a[1] + s_domain_min[1],
						o.domains[i][2] * domain_a[2] + s_domain_min[2],
					};

					std::format_to(itr, "{}\n", d);
				}
			}, obj);
		}
		
		void change_domain_range_checked(const Domain& new_domain_min, const Domain& new_domain_max) {
			std::visit([&new_domain_min, &new_domain_max](auto& o) {
				const Domain old_domain_min = o.domain_min.value_or(domain_min_default);
				const Domain old_domain_max = o.domain_max.value_or(domain_max_default);
				const Domain old_domain_dist{
					old_domain_max[0] - old_domain_min[0],
					old_domain_max[1] - old_domain_min[1],
					old_domain_max[2] - old_domain_min[2],
				};
				const Domain new_domain_dist{
					new_domain_max[0] - new_domain_min[0],
					new_domain_max[1] - new_domain_min[1],
					new_domain_max[2] - new_domain_min[2],
				};
				const Domain domain_a{
					new_domain_dist[0] / old_domain_dist[0],
					new_domain_dist[1] / old_domain_dist[1],
					new_domain_dist[2] / old_domain_dist[2],
				};

				std::for_each(
					std::execution::par_unseq,
					std::ranges::begin(o.domains), std::ranges::end(o.domains),
					[&](Domain& d) {
						d[0] = (d[0] - old_domain_min[0]) * domain_a[0] + new_domain_min[0];
						d[1] = (d[1] - old_domain_min[1]) * domain_a[1] + new_domain_min[1];
						d[2] = (d[2] - old_domain_min[2]) * domain_a[2] + new_domain_min[2];
					}
				);
				o.domain_min = new_domain_min;
				o.domain_max = new_domain_max;
			}, obj);
		}
	public:
		cube_bgra32(CubeType type, cube_base&& prop) : obj{
			[type, &prop]() mutable -> obj_t {
				switch (type) {
					case CubeType::c_1d:
						return cube1d_bgra32{ std::move(prop) };
					case CubeType::c_3d:
						return cube3d_bgra32{ std::move(prop) };
					default:
						throw type_invalid_exception{ "cube_bgra32::cube_bgra32" };
				}
			}()
		} {
			change_domain_range_checked({ 0,0,0 }, { 255,255,255 });
		}

		cube_bgra32(CubeType type, std::optional<std::string>&& title, BGRA32* data) : obj{
			[type, &title, data]() mutable -> obj_t {
				cube_base prop;
				prop.title = title;
				prop.domain_min = { 0,0,0 };
				prop.domain_max = { 255,255,255 };
				switch (type) {
					case CubeType::c_1d:
						prop.size = 256;
						prop.domains.reserve(256);
						for (int x = 0; x < 256; x++) {
							prop.domains.push_back(Domain{
								static_cast<float>(data[x][2]),
								static_cast<float>(data[x + 80 * 256][1]),
								static_cast<float>(data[x + 80 * 2 * 256][0])
							});
						}
						return cube1d_bgra32{ std::move(prop) };
					case CubeType::c_3d:
						prop.size = 64;
						prop.domains.reserve(64 * 64 * 64);
						for (int zy = 0; zy < 8; zy++) {
							for (int zx = 0; zx < 8; zx++) {
								for (int y = 0; y < 64; y++) {
									for (int x = 0; x < 64; x++) {
										auto& p = data[(zy * 64 + y) * 512 + zx * 64 + x];
										prop.domains.push_back(Domain{
											static_cast<float>(p[2]),
											static_cast<float>(p[1]),
											static_cast<float>(p[0])
										});
									}
								}
							}
						}
						return cube3d_bgra32{ std::move(prop) };
					default:
						throw type_invalid_exception{ "cube_bgra32::cube_bgra32" };
				}
			}()
		} {}

		constexpr CubeType type() const {
			return std::visit([](const auto& o) { return o.type; }, obj);
		}

		constexpr size_t size() const {
			return std::visit([](const auto& o) { return o.size; }, obj);
		}

		[[nodiscard]] constexpr auto& at(this auto&& self, size_t i) {
			return std::visit([i](auto&& o) -> auto& { return o.domains[i]; }, self.obj);
		}

		[[nodiscard]] constexpr auto& title(this auto&& self) {
			return std::visit([](auto&& o) -> auto& { return o.title; }, self.obj);
		}

		Domain index(float x, float y, float z) const {
			return std::visit<Domain>([x, y, z](const auto& o) { return o.index(x, y, z); }, obj);
		}

		static constexpr struct {
			void operator()(const auto& o, Domain& d) const {
				std::array<float, 3> idx{
					d[0] / 255.f * (o.size - 1),
					d[1] / 255.f * (o.size - 1),
					d[2] / 255.f * (o.size - 1),
				};
				d = o.index(idx[0], idx[1], idx[2]);
			}

			void operator()(const auto& o, Domain& d, float t) const {
				std::array<float, 3> idx{
					d[0] / 255.f * (o.size - 1),
					d[1] / 255.f * (o.size - 1),
					d[2] / 255.f * (o.size - 1),
				};
				d = lerp(d, o.index(idx[0], idx[1], idx[2]), t);
			}

			void operator()(const auto& o, BGRA32& p) const {
				const auto& r = o.index(p[2], p[1], p[0]);
				p[2] = static_cast<uint8_t>(std::clamp(r[0], 0.f, 255.f));
				p[1] = static_cast<uint8_t>(std::clamp(r[1], 0.f, 255.f));
				p[0] = static_cast<uint8_t>(std::clamp(r[2], 0.f, 255.f));
			}

			void operator()(const auto& o, BGRA32& p, float t) const {
				const Domain dp{
					static_cast<float>(p[2]),
					static_cast<float>(p[1]),
					static_cast<float>(p[0]),
				};
				const auto& r = lerp(dp, o.index(p[2], p[1], p[0]), t);
				p[2] = static_cast<uint8_t>(std::clamp(std::round(r[0]), 0.f, 255.f));
				p[1] = static_cast<uint8_t>(std::clamp(std::round(r[1]), 0.f, 255.f));
				p[0] = static_cast<uint8_t>(std::clamp(std::round(r[2]), 0.f, 255.f));
			}
		} apply_o{};
		
		template<class T>
		requires (std::same_as<T, Domain> || std::same_as<T, BGRA32>)
		void apply(T& v) const {
			std::visit([&v](const auto& o) { apply_o(o, v); }, obj);
		}

		template<class T>
		requires (std::same_as<T, Domain> || std::same_as<T, BGRA32>)
		void apply(T& v, float t) const {
			std::visit([&v, t](const auto& o) { apply_o(o, v, t); }, obj);
		}
		
		template<std::ranges::input_range R>
		requires std::same_as<std::ranges::range_value_t<R>, Domain> || std::same_as<std::ranges::range_value_t<R>, BGRA32>
		void apply(R&& r) const {
			std::visit([this, &r](const auto& o) {
				std::for_each(
#ifndef _DEBUG
					std::execution::par_unseq,
#endif
					std::ranges::begin(r), std::ranges::end(r),
					[this, &o](std::ranges::range_value_t<R>& v) {
						apply_o(o, v);
					}
				);
			}, obj);
		}
		
		template<std::ranges::input_range R>
		requires std::same_as<std::ranges::range_value_t<R>, Domain> || std::same_as<std::ranges::range_value_t<R>, BGRA32>
		void apply(R&& r, float t) const {
			std::visit([&r, t](const auto& o) {
				std::for_each(
#ifndef _DEBUG
					std::execution::par_unseq,
#endif
					std::ranges::begin(r), std::ranges::end(r),
					[&o, t](std::ranges::range_value_t<R>& v) {
						apply_o(o, v, t);
					}
				);
			}, obj);
		}

		void apply(BGRA32* data, size_t size, float t) const {
			std::visit([data, size, t](const auto& o) {
				for (size_t i = 0; i < size; i++) {
					apply_o(o, data[i], t);
				}
			}, obj);
		}

		void save(const std::filesystem::path& path) const {
			std::visit([&path](const auto& o) {
				std::ofstream ofs{ path, std::ios::binary };
				std::ostreambuf_iterator itr{ ofs };

				ofs << detail::HEAD_CUBEHPP_COMMENT;

				if (o.title.has_value()) std::format_to(itr, "{} \"{}\"\n", HEAD_TITLE, o.title.value());

				if (o.domain_min.has_value()) { std::format_to(itr, "{} {}\n", HEAD_DOMAIN_MIN, o.domain_min.value()); };
				if (o.domain_max.has_value()) { std::format_to(itr, "{} {}\n", HEAD_DOMAIN_MAX, o.domain_max.value()); };

				o.write_head_size(itr);

				for (size_t i : std::views::iota(size_t{ 0 }, o.get_domains_size())) {
					std::format_to(itr, "{}\n", o.domains[i]);
				}
			}, obj);
		}

		void save(const std::filesystem::path& path, float s_domain_min, float s_domain_max) const {
			if (s_domain_min >= s_domain_max) throw invalid_domain_range_exception{};

			save_checked(path, { s_domain_min,s_domain_min,s_domain_min }, { s_domain_max,s_domain_max,s_domain_max });
		}

		void save(const std::filesystem::path& path, const Domain& s_domain_min, const Domain& s_domain_max) const {
			if (!(
				s_domain_min[0] < s_domain_max[0] &&
				s_domain_min[1] < s_domain_max[1] &&
				s_domain_min[2] < s_domain_max[2]
			)) throw invalid_domain_range_exception{};

			save_checked(path, s_domain_min, s_domain_max);
		}

		void change_domain_range(float new_domain_min, float new_domain_max) {
			if (new_domain_min >= new_domain_max) throw invalid_domain_range_exception{};

			change_domain_range_checked({ new_domain_min,new_domain_min,new_domain_min }, { new_domain_max,new_domain_max,new_domain_max });
		}

		void change_domain_range(const Domain& new_domain_min, const Domain& new_domain_max) {
			if (!(
				new_domain_min[0] < new_domain_max[0] &&
				new_domain_min[1] < new_domain_max[1] &&
				new_domain_min[2] < new_domain_max[2]
			)) throw invalid_domain_range_exception{};

			change_domain_range_checked(new_domain_min, new_domain_max);
		}
	};

	inline auto cube_from_file(const std::filesystem::path& path) {
		cube_reader cr{ path };
		return cube{ cr.get_type(), std::move(*static_cast<cube_base*>(&cr)) };
	}

	inline auto cube_bgra32_from_file(const std::filesystem::path& path) {
		cube_reader cr{ path };
		return cube_bgra32{ cr.get_type(), std::move(*static_cast<cube_base*>(&cr)) };
	}
}
